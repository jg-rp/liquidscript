"use strict";(self.webpackChunkliquidscript_docs=self.webpackChunkliquidscript_docs||[]).push([[23178],{67950:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>s,metadata:()=>c,toc:()=>o});var t=i(74848),r=i(28453);const s={title:"Compatibility",description:"Known incompatibilities between LiquidScript and Ruby Liquid",hide_table_of_contents:!1},l="Known Issues",c={type:"mdx",permalink:"/liquidscript/known_issues",source:"@site/src/pages/known_issues.md",title:"Compatibility",description:"Known incompatibilities between LiquidScript and Ruby Liquid",frontMatter:{title:"Compatibility",description:"Known incompatibilities between LiquidScript and Ruby Liquid",hide_table_of_contents:!1},unlisted:!1},a={},o=[{value:"Coercing Strings to Integers Inside Filters",id:"coercing-strings-to-integers-inside-filters",level:2},{value:"Comment Parsing",id:"comment-parsing",level:2},{value:"Counters",id:"counters",level:2},{value:"Cycle Arguments",id:"cycle-arguments",level:2},{value:"Cycle Groups",id:"cycle-groups",level:2},{value:"The Date Filter",id:"the-date-filter",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Floats in Ranges",id:"floats-in-ranges",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"known-issues",children:"Known Issues"}),"\n",(0,t.jsxs)(n.p,{children:["This page documents known compatibility issues between LiquidScript and the ",(0,t.jsx)(n.a,{href:"https://shopify.github.io/liquid/",children:"reference implementation"})," of Liquid, written in Ruby. We strive to be 100% compatible with the reference implementation. That is, given an equivalent render context, a template rendered with LiquidScript should produce the same output as when rendered with Ruby Liquid."]}),"\n",(0,t.jsx)(n.h2,{id:"coercing-strings-to-integers-inside-filters",children:"Coercing Strings to Integers Inside Filters"}),"\n",(0,t.jsxs)(n.p,{children:["Many filters built in to Liquid will automatically convert a string representation of a number to an integer or float as needed. When converting integers, Ruby Liquid uses ",(0,t.jsx)(n.a,{href:"https://ruby-doc.org/core-3.1.1/String.html#method-i-to_i",children:"Ruby's String.to_i method"}),", which will disregard trailing non-digit characters. In the following example, ",(0,t.jsx)(n.code,{children:"'7,42'"})," is converted to ",(0,t.jsx)(n.code,{children:"7"})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"template:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-liquid",children:"{{ 3.14 | plus: '7,42' }}\n{{ '123abcdef45' | plus: '1,,,,..!@qwerty' }}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"output"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-plain",children:"10.14\n124\n"})}),"\n",(0,t.jsxs)(n.p,{children:["LiquidScript (and Python Liquid) currently falls back to ",(0,t.jsx)(n.code,{children:"0"})," for any string that can't be converted to an integer in its entirety. As is the case in Ruby Liquid for strings without leading digits."]}),"\n",(0,t.jsx)(n.p,{children:"This does not apply to parsing of integer literals, only converting strings to integers (not floats) inside filters."}),"\n",(0,t.jsx)(n.h2,{id:"comment-parsing",children:"Comment Parsing"}),"\n",(0,t.jsxs)(n.p,{children:["LiquidScript will throw a ",(0,t.jsx)(n.code,{children:"LiquidSyntaxError"})," if it finds the string ",(0,t.jsx)(n.code,{children:"{% endcomment %}"})," inside a comment block. Ruby Liquid, on the other hand, will successfully parse fully-formed nested comment blocks, but will fail to parse a comment block containing either a ",(0,t.jsx)(n.code,{children:"{% comment %}"})," or ",(0,t.jsx)(n.code,{children:"{% endcomment %}"})," on its own."]}),"\n",(0,t.jsx)(n.h2,{id:"counters",children:"Counters"}),"\n",(0,t.jsxs)(n.p,{children:["In Ruby Liquid, the built-in ",(0,t.jsx)(n.a,{href:"/language/tags#increment",children:(0,t.jsx)(n.code,{children:"increment"})})," and ",(0,t.jsx)(n.a,{href:"/language/tags#decrement",children:(0,t.jsx)(n.code,{children:"decrement"})}),' tags can, in some cases, mutate "global" context and keep named counters alive between renders. Although not difficult to implement, I can\'t quite bring myself to do it.']}),"\n",(0,t.jsx)(n.h2,{id:"cycle-arguments",children:"Cycle Arguments"}),"\n",(0,t.jsxs)(n.p,{children:["LiquidScript will accept ",(0,t.jsx)(n.a,{href:"/language/tags#cycle",children:(0,t.jsx)(n.code,{children:"cycle"})}),' arguments of any type, including identifiers to be resolved, this behavior is considered "unintended" or "undefined" in Ruby Liquid (see ',(0,t.jsx)(n.a,{href:"https://github.com/Shopify/liquid/issues/1519",children:"issue #1519"}),"). If you need interoperability between LiquidScript and Ruby Liquid, only use strings or numbers as arguments to ",(0,t.jsx)(n.code,{children:"cycle"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"cycle-groups",children:"Cycle Groups"}),"\n",(0,t.jsxs)(n.p,{children:["When the ",(0,t.jsx)(n.a,{href:"/language/tags#cycle",children:(0,t.jsx)(n.code,{children:"cycle"})})," tag is given a name, LiquidScript will use that name and all other arguments to distinguish one cycle from another. Ruby Liquid will disregard all other arguments when given a name. For example."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-liquid",children:'{% cycle a: 1, 2, 3 %}\n{% cycle a: "x", "y", "z" %}\n{% cycle a: 1, 2, 3 %}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Ruby Liquid Output:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-plain",children:"1\ny\n3\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"LiquidScript Output:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-plain",children:"1\nx\n2\n"})}),"\n",(0,t.jsx)(n.h2,{id:"the-date-filter",children:"The Date Filter"}),"\n",(0,t.jsxs)(n.p,{children:["The built-in ",(0,t.jsx)(n.a,{href:"/language/filters#date",children:(0,t.jsx)(n.code,{children:"date"})})," filter does not perform fuzzy date/time string parsing. Using ",(0,t.jsx)(n.a,{href:"https://github.com/moment/luxon/",children:"luxon"})," internally, it can parse well formed ISO 8601, SQL, Unix timestamp, HTTP and RFC2822 formatted date/time strings."]}),"\n",(0,t.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,t.jsx)(n.p,{children:'LiquidScript does not have a "lax" parser or a "lax" mode. LiquidScript might not handle syntax or type errors in the same way as the reference implementation. We might fail earlier or later, and will almost certainly produce a different error message.'}),"\n",(0,t.jsx)(n.h2,{id:"floats-in-ranges",children:"Floats in Ranges"}),"\n",(0,t.jsxs)(n.p,{children:["If a range literal uses a float literal as its start or stop value, the float literal must have something after the decimal point. This is OK ",(0,t.jsx)(n.code,{children:"(1.0..3)"}),". This is not ",(0,t.jsx)(n.code,{children:"(1...3)"}),". Ruby Liquid will accept either, resulting in a sequence of ",(0,t.jsx)(n.code,{children:"[1,2,3]"}),"."]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>c});var t=i(96540);const r={},s=t.createContext(r);function l(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);