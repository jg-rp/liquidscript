"use strict";(self.webpackChunkliquidscript_docs=self.webpackChunkliquidscript_docs||[]).push([[28752],{46891:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>i,metadata:()=>l,toc:()=>u});var a=t(74848),r=t(28453),s=t(11470),o=t(19365);const i={},c="Custom Loaders",l={id:"guides/custom-loaders",title:"Custom Loaders",description:"Template loaders are responsible for finding a template's source text given a name or identifier. You might want to write a custom template loader to read templates from a database, narrow the template search space for a specific user, or add extra context data to a template, for example.",source:"@site/docs/guides/custom-loaders.mdx",sourceDirName:"guides",slug:"/guides/custom-loaders",permalink:"/liquidscript/guides/custom-loaders",draft:!1,unlisted:!1,editUrl:"https://github.com/jg-rp/liquidscript/tree/docs/docs/guides/custom-loaders.mdx",tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Custom Tags",permalink:"/liquidscript/guides/custom-tags"},next:{title:"Template Static Analysis",permalink:"/liquidscript/guides/static-analysis"}},d={},u=[{value:"Example Map Loader",id:"example-map-loader",level:2},{value:"Loading Sections and Snippets",id:"loading-sections-and-snippets",level:2},{value:"Caching Loaders",id:"caching-loaders",level:2},{value:"Front Matter Loader",id:"front-matter-loader",level:2},{value:"Scoped Database Loader",id:"scoped-database-loader",level:2}];function p(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"custom-loaders",children:"Custom Loaders"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"/liquidscript/introduction/loading-templates#built-in-template-loaders",children:"Template loaders"})," are responsible for finding a template's source text given a name or identifier. You might want to write a custom template loader to read templates from a database, narrow the template search space for a specific user, or add extra context data to a template, for example."]}),"\n",(0,a.jsxs)(n.p,{children:["Write a custom template loader by extending the ",(0,a.jsx)(n.a,{href:"/liquidscript/api/classes/Loader",children:(0,a.jsx)(n.code,{children:"Loader"})})," base class and implementing its ",(0,a.jsx)(n.a,{href:"/liquidscript/api/classes/Loader#getsource",children:(0,a.jsx)(n.code,{children:"getSource()"})})," and ",(0,a.jsx)(n.a,{href:"/liquidscript/api/classes/Loader#getsourcesync",children:(0,a.jsx)(n.code,{children:"getSourceSync()"})})," methods. Then configure an ",(0,a.jsx)(n.a,{href:"/liquidscript/api/classes/Environment",children:(0,a.jsx)(n.code,{children:"Environment"})})," to use your loader with the ",(0,a.jsx)(n.a,{href:"/liquidscript/api/type-aliases/EnvironmentOptions#loader",children:(0,a.jsx)(n.code,{children:"loader"})})," option."]}),"\n",(0,a.jsx)(n.h2,{id:"example-map-loader",children:"Example Map Loader"}),"\n",(0,a.jsxs)(n.p,{children:["This example loader reads templates from a ",(0,a.jsx)(n.code,{children:"Map"})," of template names to template source text strings."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"/liquidscript/api/classes/Loader#getsource",children:(0,a.jsx)(n.code,{children:"getSource()"})})," and ",(0,a.jsx)(n.a,{href:"/liquidscript/api/classes/Loader#getsourcesync",children:(0,a.jsx)(n.code,{children:"getSourceSync()"})})," are expected to return a ",(0,a.jsx)(n.a,{href:"/liquidscript/api/classes/TemplateSource",children:(0,a.jsx)(n.code,{children:"TemplateSource"})})," object representing the template source and associated meta data. If a template's source can not be found, ",(0,a.jsx)(n.a,{href:"/liquidscript/api/classes/Loader#getsource",children:(0,a.jsx)(n.code,{children:"getSource()"})})," and ",(0,a.jsx)(n.a,{href:"/liquidscript/api/classes/Loader#getsourcesync",children:(0,a.jsx)(n.code,{children:"getSourceSync()"})})," should throw a ",(0,a.jsx)(n.a,{href:"/liquidscript/api/classes/TemplateNotFoundError",children:(0,a.jsx)(n.code,{children:"TemplateNotFoundError"})}),"."]}),"\n",(0,a.jsxs)(s.A,{groupId:"js-ts",children:[(0,a.jsx)(o.A,{value:"js",label:"JavaScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'import { Loader, TemplateSource, TemplateNotFoundError } from "liquidscript";\n\nexport class MapLoader extends Loader {\n  #map;\n\n  constructor(map) {\n    super();\n    this.#map = map === undefined ? new Map() : map;\n  }\n\n  async getSource(name) {\n    return this.getSourceSync(name);\n  }\n\n  getSourceSync(name) {\n    const source = this.#map.get(name);\n    if (source === undefined) throw new TemplateNotFoundError(name);\n    return new TemplateSource(source, name);\n  }\n}\n'})})}),(0,a.jsx)(o.A,{value:"ts",label:"TypeScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'import { Loader, TemplateSource, TemplateNotFoundError } from "liquidscript";\n\nclass MapLoader extends Loader {\n  #templateMap: Map<string, string>;\n\n  constructor(map?: Map<string, string>) {\n    super();\n    this.#templateMap = map === undefined ? new Map<string, string>() : map;\n  }\n\n  public async getSource(name: string): Promise<TemplateSource> {\n    return this.getSourceSync(name);\n  }\n\n  public getSourceSync(name: string): TemplateSource {\n    const source = this.#templateMap.get(name);\n    if (source === undefined) throw new TemplateNotFoundError(name);\n    return new TemplateSource(source, name);\n  }\n}\n'})})})]}),"\n",(0,a.jsxs)(n.p,{children:["If ",(0,a.jsx)(n.code,{children:"MapLoader"})," is exported from a ",(0,a.jsx)(n.code,{children:'"my_loaders"'})," module, we can import it and configure an ",(0,a.jsx)(n.code,{children:"Environment"})," to use it like this."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'import { Environment } from "liquidscript";\nimport { MapLoader } from "./my_loaders";\n\nconst templates = new Map([\n  ["some_template", "{% include \'some_snippet\' %}"],\n  ["some_snippet", "Hello, {{ you }}!"],\n]);\n\nconst env = new Environment({ loader: new MapLoader(templates) });\nconst template = env.getTemplateSync("some_template");\nconsole.log(template.renderSync({ you: "World" }));\n// Hello, World!\n'})}),"\n",(0,a.jsx)(n.h2,{id:"loading-sections-and-snippets",children:"Loading Sections and Snippets"}),"\n",(0,a.jsxs)(n.p,{children:["We can mimic ",(0,a.jsx)(n.a,{href:"https://shopify.dev/api/liquid/tags/theme-tags#render",children:"Shopify's snippet"})," and ",(0,a.jsx)(n.a,{href:"https://shopify.dev/api/liquid/tags/theme-tags#section",children:"static section"})," loading behavior with a custom template loader and ",(0,a.jsx)(n.code,{children:"section"})," tag. This example will look for templates rendered with ",(0,a.jsx)(n.code,{children:"{% include %}"})," or ",(0,a.jsx)(n.code,{children:"{% render %}"})," in a ",(0,a.jsx)(n.code,{children:"snippets"})," subfolder, those rendered with ",(0,a.jsx)(n.code,{children:"{% section %}"})," in a ",(0,a.jsx)(n.code,{children:"section"})," subfolder, and all other templates in a ",(0,a.jsx)(n.code,{children:"templates"})," subfolder."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"SectionLoader"})," makes use of the ",(0,a.jsx)(n.code,{children:"LoaderContext"})," object passed to ",(0,a.jsx)(n.code,{children:"getSource()"})," and ",(0,a.jsx)(n.code,{children:"getSourceSync()"}),". ",(0,a.jsx)(n.code,{children:"LoaderContext"})," can contain any arbitrary objects and primitives that a template loader might use to modify its search space or retrieve extra template meta data. By convention, the built in ",(0,a.jsx)(n.a,{href:"/liquidscript/language/tags#include",children:(0,a.jsx)(n.code,{children:"include"})})," and ",(0,a.jsx)(n.a,{href:"/liquidscript/language/tags#render",children:(0,a.jsx)(n.code,{children:"render"})})," tags add a ",(0,a.jsx)(n.code,{children:"tag"})," property to their ",(0,a.jsx)(n.code,{children:"LoaderContext"}),", allowing us to determine which tag, if any, is trying to load a template."]}),"\n",(0,a.jsxs)(s.A,{groupId:"js-ts",children:[(0,a.jsx)(o.A,{value:"js",label:"JavaScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:"title=section_loader.js",children:'import fsCallback from "fs";\nimport fs from "fs/promises";\nimport path from "path";\n\nimport {\n  Loader,\n  TemplateSource,\n  TemplateNotFoundError,\n  object,\n  tags,\n} from "liquidscript";\n\nclass SectionLoader extends Loader {\n  #path;\n  #sections;\n  #snippets;\n  #templates;\n  encoding = "utf8";\n  fileExtension = ".liquid";\n\n  constructor(searchPath) {\n    super();\n    this.#path = searchPath;\n    this.#sections = path.join(this.#path, "sections");\n    this.#snippets = path.join(this.#path, "snippets");\n    this.#templates = path.join(this.#path, "templates");\n  }\n\n  async getSource(name, renderContext, loaderContext) {\n    const templatePath = await this.resolve(\n      this.withFileExtension(name),\n      object.liquidStringify(\n        loaderContext === undefined ? undefined : loaderContext.tag\n      )\n    );\n    const source = await fs.readFile(templatePath, { encoding: this.encoding });\n    return new TemplateSource(source, templatePath);\n  }\n\n  getSourceSync(name, renderContext, loaderContext) {\n    const templatePath = this.resolveSync(\n      this.withFileExtension(name),\n      object.liquidStringify(\n        loaderContext === undefined ? undefined : loaderContext.tag\n      )\n    );\n    const source = fsCallback.readFileSync(templatePath, {\n      encoding: this.encoding,\n    });\n    return new TemplateSource(source, templatePath);\n  }\n\n  withFileExtension(name) {\n    return path.extname(name) ? name : name + this.fileExtension;\n  }\n\n  async resolve(name, tag) {\n    const searchPath = this.resolveTag(tag);\n    const templatePath = path.join(searchPath, path.normalize(name));\n\n    if (!isSubPath(searchPath, templatePath))\n      throw new TemplateNotFoundError(name);\n\n    try {\n      const stat = await fs.stat(templatePath);\n      if (stat.isFile()) return templatePath;\n      throw new TemplateNotFoundError(name);\n    } catch {\n      throw new TemplateNotFoundError(name);\n    }\n  }\n\n  resolveSync(name, tag) {\n    const searchPath = this.resolveTag(tag);\n    const templatePath = path.join(searchPath, path.normalize(name));\n\n    if (!isSubPath(searchPath, templatePath))\n      throw new TemplateNotFoundError(name);\n\n    try {\n      const stat = fsCallback.statSync(templatePath);\n      if (stat.isFile()) return templatePath;\n      throw new TemplateNotFoundError(name);\n    } catch {\n      throw new TemplateNotFoundError(name);\n    }\n  }\n\n  resolveTag(tag) {\n    switch (tag) {\n      case "render":\n      case "include":\n        return this.#snippets;\n      case "section":\n        return this.#sections;\n      case "":\n        return this.#templates;\n      default:\n        throw new TemplateNotFoundError(\n          "SectionLoader can only load \'render\', \'include\' and \'section\' tags"\n        );\n    }\n  }\n}\n\nfunction isSubPath(parent, dir) {\n  const relative = path.relative(parent, dir);\n  return !!relative && !relative.startsWith(".") && !path.isAbsolute(relative);\n}\n'})})}),(0,a.jsx)(o.A,{value:"ts",label:"TypeScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",metastring:'title="section_loader.ts"',children:'import fsCallback from "fs";\nimport fs from "fs/promises";\nimport path from "path";\n\nimport {\n  Loader,\n  RenderContext,\n  TemplateSource,\n  TemplateNotFoundError,\n  object,\n  tags,\n} from "liquidscript";\n\nclass SectionLoader extends Loader {\n  #path: string;\n  #sections: string;\n  #snippets: string;\n  #templates: string;\n  readonly encoding: BufferEncoding = "utf8";\n  readonly fileExtension: string = ".liquid";\n\n  constructor(searchPath: string) {\n    super();\n    this.#path = searchPath;\n    this.#sections = path.join(this.#path, "sections");\n    this.#snippets = path.join(this.#path, "snippets");\n    this.#templates = path.join(this.#path, "templates");\n  }\n\n  public async getSource(\n    name: string,\n    renderContext?: RenderContext,\n    loaderContext?: { [index: string]: unknown }\n  ): Promise<TemplateSource> {\n    const templatePath = await this.resolve(\n      this.withFileExtension(name),\n      object.liquidStringify(loaderContext?.tag)\n    );\n    const source = await fs.readFile(templatePath, { encoding: this.encoding });\n    return new TemplateSource(source, templatePath);\n  }\n\n  public getSourceSync(\n    name: string,\n    renderContext?: RenderContext,\n    loaderContext?: { [index: string]: unknown }\n  ): TemplateSource {\n    const templatePath = this.resolveSync(\n      this.withFileExtension(name),\n      object.liquidStringify(loaderContext?.tag)\n    );\n    const source = fsCallback.readFileSync(templatePath, {\n      encoding: this.encoding,\n    });\n    return new TemplateSource(source, templatePath);\n  }\n\n  protected withFileExtension(name: string): string {\n    return path.extname(name) ? name : name + this.fileExtension;\n  }\n\n  protected async resolve(name: string, tag: string): Promise<string> {\n    const searchPath = this.resolveTag(tag);\n    const templatePath = path.join(searchPath, path.normalize(name));\n\n    if (!isSubPath(searchPath, templatePath))\n      throw new TemplateNotFoundError(name);\n\n    try {\n      const stat = await fs.stat(templatePath);\n      if (stat.isFile()) return templatePath;\n      throw new TemplateNotFoundError(name);\n    } catch {\n      throw new TemplateNotFoundError(name);\n    }\n  }\n\n  protected resolveSync(name: string, tag: string): string {\n    const searchPath = this.resolveTag(tag);\n    const templatePath = path.join(searchPath, path.normalize(name));\n\n    if (!isSubPath(searchPath, templatePath))\n      throw new TemplateNotFoundError(name);\n\n    try {\n      const stat = fsCallback.statSync(templatePath);\n      if (stat.isFile()) return templatePath;\n      throw new TemplateNotFoundError(name);\n    } catch {\n      throw new TemplateNotFoundError(name);\n    }\n  }\n\n  protected resolveTag(tag: string): string {\n    switch (tag) {\n      case "render":\n      case "include":\n        return this.#snippets;\n      case "section":\n        return this.#sections;\n      case "":\n        return this.#templates;\n      default:\n        throw new TemplateNotFoundError(\n          "SectionLoader can only load \'render\', \'include\' and \'section\' tags"\n        );\n    }\n  }\n}\n\nfunction isSubPath(parent: string, dir: string): boolean {\n  const relative = path.relative(parent, dir);\n  return !!relative && !relative.startsWith(".") && !path.isAbsolute(relative);\n}\n'})})})]}),"\n",(0,a.jsxs)(n.p,{children:["Our ",(0,a.jsx)(n.code,{children:"section"})," tag is a minimal extension of the ",(0,a.jsx)(n.a,{href:"/liquidscript/language/tags#include",children:(0,a.jsx)(n.code,{children:"include"})})," tag."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:'title="section_tag.js"',children:'class SectionTag extends tags.IncludeTag {\n  name = "section";\n  nodeClass = SectionNode;\n}\n\nclass SectionNode extends tags.IncludeNode {\n  tag = "section";\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["With ",(0,a.jsx)(n.code,{children:"SectionLoader"})," exported from a ",(0,a.jsx)(n.code,{children:'"section_loader"'})," module and ",(0,a.jsx)(n.code,{children:"SectionTag"})," exported from ",(0,a.jsx)(n.code,{children:'"section_tag"'}),", we can configure an ",(0,a.jsx)(n.a,{href:"/liquidscript/api/classes/Environment",children:(0,a.jsx)(n.code,{children:"Environment"})})," like this."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'import { Environment, StrictUndefined } from "liquidscript";\nimport { SectionLoader } from "./section_loader";\nimport { SectionTag } from "./section_tag";\n\nconst env = new Environment({\n  loader: new SectionLoader("templates/"),\n  undefinedFactory: StrictUndefined.from,\n});\n\nenv.addTag("section", new SectionTag());\n'})}),"\n",(0,a.jsx)(n.h2,{id:"caching-loaders",children:"Caching Loaders"}),"\n",(0,a.jsxs)(n.p,{children:["Parsing a Liquid template is significantly slower than rendering a Liquid template (not including render-time IO). As such, we should cache parsed templates where possible to prevent the same template being parsed multiple times unnecessarily. One example scenario where even a modest in-memory cache can yield a noticeable performance improvement is that of ",(0,a.jsx)(n.a,{href:"/liquidscript/language/tags#include",children:"including"})," a partial template repeatedly inside a ",(0,a.jsx)(n.a,{href:"/liquidscript/language/tags#for",children:"for loop"}),"."]}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.p,{children:["Please see the implementation of ",(0,a.jsx)(n.code,{children:"CachingNodeFileSystemLoader"})," in ",(0,a.jsx)(n.a,{href:"https://github.com/jg-rp/liquidscript/blob/main/src/builtin/loaders/file_system_loader.ts",children:"src/builtin/loaders/file_system_loader.ts"})," for a full example."]})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"/liquidscript/api/classes/CachingNodeFileSystemLoader",children:(0,a.jsx)(n.code,{children:"CachingNodeFileSystemLoader"})})," overrides ",(0,a.jsx)(n.a,{href:"/liquidscript/api/classes/Loader#load",children:(0,a.jsx)(n.code,{children:"load()"})})," and ",(0,a.jsx)(n.a,{href:"/liquidscript/api/classes/Loader#loadsync",children:(0,a.jsx)(n.code,{children:"loadSync()"})})," of its parent ",(0,a.jsx)(n.a,{href:"/liquidscript/api/classes/Loader",children:(0,a.jsx)(n.code,{children:"Loader"})})," class. It uses an ",(0,a.jsx)(n.a,{href:"/liquidscript/api/classes/LRUCache",children:(0,a.jsx)(n.code,{children:"LRUCache"})}),", which is checked before delegating to ",(0,a.jsx)(n.code,{children:"getSource()"})," and ",(0,a.jsx)(n.code,{children:"getSourceSync()"})," in the event of a cache miss."]}),"\n",(0,a.jsxs)(n.p,{children:["The optional ",(0,a.jsx)(n.a,{href:"/liquidscript/api/classes/TemplateSource#uptodate",children:(0,a.jsx)(n.code,{children:"upToDate"})})," and ",(0,a.jsx)(n.a,{href:"/liquidscript/api/classes/TemplateSource#uptodatesync",children:(0,a.jsx)(n.code,{children:"upToDateSync"})})," properties of a ",(0,a.jsx)(n.a,{href:"/liquidscript/api/classes/TemplateSource",children:(0,a.jsx)(n.code,{children:"TemplateSource"})})," provide a way to bust a template cache if the underlying source text has been modified."]}),"\n",(0,a.jsx)(n.h2,{id:"front-matter-loader",children:"Front Matter Loader"}),"\n",(0,a.jsxs)(n.p,{children:["A ",(0,a.jsx)(n.a,{href:"/liquidscript/api/classes/TemplateSource",children:(0,a.jsx)(n.code,{children:"TemplateSource"})})," object, as returned by ",(0,a.jsx)(n.a,{href:"/liquidscript/api/classes/Loader#getsource",children:(0,a.jsx)(n.code,{children:"getSource()"})})," and ",(0,a.jsx)(n.a,{href:"/liquidscript/api/classes/Loader#getsourcesync",children:(0,a.jsx)(n.code,{children:"getSourceSync()"})})," of a template ",(0,a.jsx)(n.a,{href:"/liquidscript/api/classes/Loader",children:(0,a.jsx)(n.code,{children:"Loader"})}),", optionally includes a ",(0,a.jsx)(n.a,{href:"/liquidscript/api/classes/TemplateSource#matter",children:(0,a.jsx)(n.code,{children:"matter"})})," property. If given, ",(0,a.jsx)(n.code,{children:"matter"})," should be extra render context data in addition to ",(0,a.jsx)(n.a,{href:"/liquidscript/introduction/render-context#environment-globals",children:"environment globals"})," and ",(0,a.jsx)(n.a,{href:"/liquidscript/introduction/render-context#template-globals",children:"template globals"}),". Like template globals, matter data is pinned to a template and will be merged with environment globals at render time."]}),"\n",(0,a.jsxs)(n.p,{children:["This example implements a front matter template loader by extending ",(0,a.jsx)(n.a,{href:"/liquidscript/api/classes/NodeFileSystemLoader",children:(0,a.jsx)(n.code,{children:"NodeFileSystemLoader"})})," and parsing ",(0,a.jsx)(n.a,{href:"https://yaml.org/",children:"YAML"})," from the start of a every template source file."]}),"\n",(0,a.jsxs)(s.A,{groupId:"js-ts",children:[(0,a.jsx)(o.A,{value:"js",label:"JavaScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'import {\n  Environment,\n  NodeFileSystemLoader,\n  TemplateSource,\n} from "liquidscript";\n\nimport yaml from "js-yaml";\n\nconst RE_FRONT_MATTER = /^\\s*---\\s*(.*?)\\s*---\\s*/ms;\n\nclass FrontMatterLoader extends NodeFileSystemLoader {\n  async getSource(name) {\n    return this.loadMatter(await super.getSource(name));\n  }\n\n  getSourceSync(name) {\n    return this.loadMatter(super.getSourceSync(name));\n  }\n\n  loadMatter(templateSource) {\n    const match = templateSource.source.match(RE_FRONT_MATTER);\n    if (match) {\n      // TODO: check YAML schema and handle YAML errors\n      const matter = yaml.load(match[1]);\n      return new TemplateSource(\n        templateSource.source.slice(match[0].length),\n        templateSource.name,\n        matter,\n        templateSource.upToDate,\n        templateSource.upToDateSync\n      );\n    }\n    return templateSource;\n  }\n}\n'})})}),(0,a.jsx)(o.A,{value:"ts",label:"TypeScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'import {\n  ContextScope,\n  NodeFileSystemLoader,\n  object,\n  TemplateSource,\n} from "liquidscript";\n\nimport yaml from "js-yaml";\n\nconst RE_FRONT_MATTER = /^\\s*---\\s*(.*?)\\s*---\\s*/ms;\n\nclass FrontMatterLoader extends NodeFileSystemLoader {\n  public async getSource(name: string): Promise<TemplateSource> {\n    return this.loadMatter(await super.getSource(name));\n  }\n\n  public getSourceSync(name: string): TemplateSource {\n    return this.loadMatter(super.getSourceSync(name));\n  }\n\n  protected loadMatter(templateSource: TemplateSource): TemplateSource {\n    const match = templateSource.source.match(RE_FRONT_MATTER);\n    if (match) {\n      // TODO: check YAML schema and handle YAML errors\n      const matter = yaml.load(match[1]);\n      if (object.isContextScope(matter)) {\n        return new TemplateSource(\n          templateSource.source.slice(match[0].length),\n          templateSource.name,\n          matter,\n          templateSource.upToDate,\n          templateSource.upToDateSync\n        );\n      }\n    }\n    return templateSource;\n  }\n}\n'})})})]}),"\n",(0,a.jsx)(n.h2,{id:"scoped-database-loader",children:"Scoped Database Loader"}),"\n",(0,a.jsxs)(n.p,{children:["We can implement a ",(0,a.jsx)(n.em,{children:"scoped"})," template loader using the ",(0,a.jsx)(n.code,{children:"loaderContext"})," argument to ",(0,a.jsx)(n.a,{href:"/liquidscript/api/classes/Environment#gettemplate",children:(0,a.jsx)(n.code,{children:"getTemplate()"})})," or as part of the ",(0,a.jsx)(n.code,{children:"templateContext"})," argument to ",(0,a.jsx)(n.a,{href:"/liquidscript/api/classes/Environment#fromstring",children:(0,a.jsx)(n.code,{children:"fromString()"})}),". A scoped template loader is useful for multi-user application where each user has their own collection of templates."]}),"\n",(0,a.jsxs)(n.p,{children:["This example loader reads templates from a MongoDB database, narrowing its search space using a ",(0,a.jsx)(n.code,{children:"uid"})," property set on the ",(0,a.jsx)(n.code,{children:"loaderContext"})," object passed to ",(0,a.jsx)(n.a,{href:"/liquidscript/api/classes/Loader#getsource",children:(0,a.jsx)(n.code,{children:"getSource()"})}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",metastring:'title="mongo_loader.mjs"',children:'import { Loader, TemplateNotFoundError, TemplateSource } from "liquidscript";\n\nexport class MongoDBLoader extends Loader {\n  constructor(collection) {\n    super();\n    this.collection = collection;\n    this.re = /[a-zA-Z][a-zA-Z0-9_\\-]+/;\n  }\n\n  async getSource(name, renderContext, loaderContext) {\n    const uid = loaderContext !== undefined ? loaderContext.uid : undefined;\n    if (uid === undefined)\n      throw new TemplateNotFoundError(\n        "MongoDBLoader requires a loader context with a \'uid\' property"\n      );\n\n    if (!this.re.test(name))\n      throw new TemplateNotFoundError(`invalid template name: ${name}`);\n\n    const query = { uid: uid, [`templates.${name}`]: { $exists: 1 } };\n    const projection = { _id: 0, [`templates.${name}`]: 1 };\n\n    const result = await this.collection.findOne(query, projection);\n    if (!result) throw new TemplateNotFoundError(name);\n    return new TemplateSource(result.templates[name], name);\n  }\n\n  getSourceSync() {\n    throw new Error("MongoDBLoader is an async only loader");\n  }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"MongoDBLoader"})," constructor expects a MongoDB ",(0,a.jsx)(n.code,{children:"Collection"})," from an already connected client, and that documents in that collection have a ",(0,a.jsx)(n.code,{children:"uid"})," and ",(0,a.jsx)(n.code,{children:"templates"})," field. Fields in the embedded ",(0,a.jsx)(n.code,{children:"templates"})," document are Liquid template names and their values are Liquid template source text strings."]}),"\n",(0,a.jsxs)(n.p,{children:["If ",(0,a.jsx)(n.code,{children:"MongoDBLoader"})," is exported from the module ",(0,a.jsx)(n.code,{children:'"mongo_loader.mjs"'}),", we could use it like this."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'import { Environment } from "liquidscript";\nimport { MongoClient } from "mongodb";\nimport { MongoDBLoader } from "./mongo_loader";\n\nconst uri = "mongodb://<somehost>";\nconst client = new MongoClient(uri);\n\nasync function run() {\n  try {\n    await client.connect();\n    const db = client.db("mydatabase");\n    const col = db.collection("mycollection");\n    const env = new Environment({ loader: new MongoDBLoader(col) });\n\n    const template = await env.getTemplate("index", undefined, undefined, {\n      uid: "ABC0123",\n    });\n\n    const result = await template.render();\n    console.log(result);\n  } finally {\n    await client.close();\n  }\n}\nrun().catch(console.dir);\n'})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}},19365:(e,n,t)=>{t.d(n,{A:()=>o});t(96540);var a=t(34164);const r={tabItem:"tabItem_Ymn6"};var s=t(74848);function o(e){let{children:n,hidden:t,className:o}=e;return(0,s.jsx)("div",{role:"tabpanel",className:(0,a.A)(r.tabItem,o),hidden:t,children:n})}},11470:(e,n,t)=>{t.d(n,{A:()=>v});var a=t(96540),r=t(34164),s=t(23104),o=t(56347),i=t(205),c=t(57485),l=t(31682),d=t(70679);function u(e){return a.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function p(e){const{values:n,children:t}=e;return(0,a.useMemo)((()=>{const e=n??function(e){return u(e).map((e=>{let{props:{value:n,label:t,attributes:a,default:r}}=e;return{value:n,label:t,attributes:a,default:r}}))}(t);return function(e){const n=(0,l.X)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function h(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function m(e){let{queryString:n=!1,groupId:t}=e;const r=(0,o.W6)(),s=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,c.aZ)(s),(0,a.useCallback)((e=>{if(!s)return;const n=new URLSearchParams(r.location.search);n.set(s,e),r.replace({...r.location,search:n.toString()})}),[s,r])]}function g(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,s=p(e),[o,c]=(0,a.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!h({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const a=t.find((e=>e.default))??t[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:s}))),[l,u]=m({queryString:t,groupId:r}),[g,x]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[r,s]=(0,d.Dv)(t);return[r,(0,a.useCallback)((e=>{t&&s.set(e)}),[t,s])]}({groupId:r}),f=(()=>{const e=l??g;return h({value:e,tabValues:s})?e:null})();(0,i.A)((()=>{f&&c(f)}),[f]);return{selectedValue:o,selectValue:(0,a.useCallback)((e=>{if(!h({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);c(e),u(e),x(e)}),[u,x,s]),tabValues:s}}var x=t(92303);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var j=t(74848);function S(e){let{className:n,block:t,selectedValue:a,selectValue:o,tabValues:i}=e;const c=[],{blockElementScrollPositionUntilNextRender:l}=(0,s.a_)(),d=e=>{const n=e.currentTarget,t=c.indexOf(n),r=i[t].value;r!==a&&(l(n),o(r))},u=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const t=c.indexOf(e.currentTarget)+1;n=c[t]??c[0];break}case"ArrowLeft":{const t=c.indexOf(e.currentTarget)-1;n=c[t]??c[c.length-1];break}}n?.focus()};return(0,j.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":t},n),children:i.map((e=>{let{value:n,label:t,attributes:s}=e;return(0,j.jsx)("li",{role:"tab",tabIndex:a===n?0:-1,"aria-selected":a===n,ref:e=>c.push(e),onKeyDown:u,onClick:d,...s,className:(0,r.A)("tabs__item",f.tabItem,s?.className,{"tabs__item--active":a===n}),children:t??n},n)}))})}function b(e){let{lazy:n,children:t,selectedValue:r}=e;const s=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=s.find((e=>e.props.value===r));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return(0,j.jsx)("div",{className:"margin-top--md",children:s.map(((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==r})))})}function y(e){const n=g(e);return(0,j.jsxs)("div",{className:(0,r.A)("tabs-container",f.tabList),children:[(0,j.jsx)(S,{...n,...e}),(0,j.jsx)(b,{...n,...e})]})}function v(e){const n=(0,x.A)();return(0,j.jsx)(y,{...e,children:u(e.children)},String(n))}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var a=t(96540);const r={},s=a.createContext(r);function o(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);