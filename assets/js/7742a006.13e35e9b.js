"use strict";(self.webpackChunkliquidscript_docs=self.webpackChunkliquidscript_docs||[]).push([[8870],{9494:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var i=n(6687);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=i.createContext({}),u=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=u(e.components);return i.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=u(n),m=r,g=d["".concat(s,".").concat(m)]||d[m]||c[m]||a;return n?i.createElement(g,l(l({ref:t},p),{},{components:n})):i.createElement(g,l({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,l=new Array(a);l[0]=d;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var u=2;u<a;u++)l[u]=n[u];return i.createElement.apply(null,l)}return i.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3222:function(e,t,n){n.r(t),n.d(t,{contentTitle:function(){return s},default:function(){return d},frontMatter:function(){return o},metadata:function(){return u},toc:function(){return p}});var i=n(9853),r=n(5309),a=(n(6687),n(9494)),l=["components"],o={title:"Compatibility",description:"Known incompatibilities between LiquidScript and Ruby Liquid",hide_table_of_contents:!1},s="Known Issues",u={type:"mdx",permalink:"/liquidscript/known_issues",source:"@site/src/pages/known_issues.md",title:"Compatibility",description:"Known incompatibilities between LiquidScript and Ruby Liquid",frontMatter:{title:"Compatibility",description:"Known incompatibilities between LiquidScript and Ruby Liquid",hide_table_of_contents:!1}},p=[{value:"Coercing Strings to Integers Inside Filters",id:"coercing-strings-to-integers-inside-filters",level:2},{value:"Comment Parsing",id:"comment-parsing",level:2},{value:"Counters",id:"counters",level:2},{value:"Cycle Arguments",id:"cycle-arguments",level:2},{value:"Cycle Groups",id:"cycle-groups",level:2},{value:"The Date Filter",id:"the-date-filter",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Floats in Ranges",id:"floats-in-ranges",level:2}],c={toc:p};function d(e){var t=e.components,n=(0,r.Z)(e,l);return(0,a.kt)("wrapper",(0,i.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"known-issues"},"Known Issues"),(0,a.kt)("p",null,"This page documents known compatibility issues between LiquidScript and the ",(0,a.kt)("a",{parentName:"p",href:"https://shopify.github.io/liquid/"},"reference implementation")," of Liquid, written in Ruby. We strive to be 100% compatible with the reference implementation. That is, given an equivalent render context, a template rendered with LiquidScript should produce the same output as when rendered with Ruby Liquid."),(0,a.kt)("h2",{id:"coercing-strings-to-integers-inside-filters"},"Coercing Strings to Integers Inside Filters"),(0,a.kt)("p",null,"Many filters built in to Liquid will automatically convert a string representation of a number to an integer or float as needed. When converting integers, Ruby Liquid uses ",(0,a.kt)("a",{parentName:"p",href:"https://ruby-doc.org/core-3.1.1/String.html#method-i-to_i"},"Ruby's String.to_i method"),", which will disregard trailing non-digit characters. In the following example, ",(0,a.kt)("inlineCode",{parentName:"p"},"'7,42'")," is converted to ",(0,a.kt)("inlineCode",{parentName:"p"},"7")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"template:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-liquid"},"{{ 3.14 | plus: '7,42' }}\n{{ '123abcdef45' | plus: '1,,,,..!@qwerty' }}\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"output")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-plain"},"10.14\n124\n")),(0,a.kt)("p",null,"LiquidScript (and Python Liquid) currently falls back to ",(0,a.kt)("inlineCode",{parentName:"p"},"0")," for any string that can't be converted to an integer in its entirety. As is the case in Ruby Liquid for strings without leading digits."),(0,a.kt)("p",null,"This does not apply to parsing of integer literals, only converting strings to integers (not floats) inside filters."),(0,a.kt)("h2",{id:"comment-parsing"},"Comment Parsing"),(0,a.kt)("p",null,"LiquidScript will throw a ",(0,a.kt)("inlineCode",{parentName:"p"},"LiquidSyntaxError")," if it finds the string ",(0,a.kt)("inlineCode",{parentName:"p"},"{% endcomment %}")," inside a comment block. Ruby Liquid, on the other hand, will successfully parse fully-formed nested comment blocks, but will fail to parse a comment block containing either a ",(0,a.kt)("inlineCode",{parentName:"p"},"{% comment %}")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"{% endcomment %}")," on its own."),(0,a.kt)("h2",{id:"counters"},"Counters"),(0,a.kt)("p",null,"In Ruby Liquid, the built-in ",(0,a.kt)("a",{parentName:"p",href:"/language/tags#increment"},(0,a.kt)("inlineCode",{parentName:"a"},"increment"))," and ",(0,a.kt)("a",{parentName:"p",href:"/language/tags#decrement"},(0,a.kt)("inlineCode",{parentName:"a"},"decrement")),' tags can, in some cases, mutate "global" context and keep named counters alive between renders. Although not difficult to implement, I can\'t quite bring myself to do it.'),(0,a.kt)("h2",{id:"cycle-arguments"},"Cycle Arguments"),(0,a.kt)("p",null,"LiquidScript will accept ",(0,a.kt)("a",{parentName:"p",href:"/language/tags#cycle"},(0,a.kt)("inlineCode",{parentName:"a"},"cycle")),' arguments of any type, including identifiers to be resolved, this behavior is considered "unintended" or "undefined" in Ruby Liquid (see ',(0,a.kt)("a",{parentName:"p",href:"https://github.com/Shopify/liquid/issues/1519"},"issue #1519"),"). If you need interoperability between LiquidScript and Ruby Liquid, only use strings or numbers as arguments to ",(0,a.kt)("inlineCode",{parentName:"p"},"cycle"),"."),(0,a.kt)("h2",{id:"cycle-groups"},"Cycle Groups"),(0,a.kt)("p",null,"When the ",(0,a.kt)("a",{parentName:"p",href:"/language/tags#cycle"},(0,a.kt)("inlineCode",{parentName:"a"},"cycle"))," tag is given a name, LiquidScript will use that name and all other arguments to distinguish one cycle from another. Ruby Liquid will disregard all other arguments when given a name. For example."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-liquid"},'{% cycle a: 1, 2, 3 %}\n{% cycle a: "x", "y", "z" %}\n{% cycle a: 1, 2, 3 %}\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Ruby Liquid Output:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-plain"},"1\ny\n3\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"LiquidScript Output:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-plain"},"1\nx\n2\n")),(0,a.kt)("h2",{id:"the-date-filter"},"The Date Filter"),(0,a.kt)("p",null,"The built-in ",(0,a.kt)("a",{parentName:"p",href:"/language/filters#date"},(0,a.kt)("inlineCode",{parentName:"a"},"date"))," filter does not perform fuzzy date/time string parsing. Using ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/moment/luxon/"},"luxon")," internally, it can parse well formed ISO 8601, SQL, Unix timestamp, HTTP and RFC2822 formatted date/time strings."),(0,a.kt)("h2",{id:"error-handling"},"Error Handling"),(0,a.kt)("p",null,'LiquidScript does not have a "lax" parser or a "lax" mode. LiquidScript might not handle syntax or type errors in the same way as the reference implementation. We might fail earlier or later, and will almost certainly produce a different error message.'),(0,a.kt)("h2",{id:"floats-in-ranges"},"Floats in Ranges"),(0,a.kt)("p",null,"If a range literal uses a float literal as its start or stop value, the float literal must have something after the decimal point. This is OK ",(0,a.kt)("inlineCode",{parentName:"p"},"(1.0..3)"),". This is not ",(0,a.kt)("inlineCode",{parentName:"p"},"(1...3)"),". Ruby Liquid will accept either, resulting in a sequence of ",(0,a.kt)("inlineCode",{parentName:"p"},"[1,2,3]"),"."))}d.isMDXComponent=!0}}]);